(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{186:function(n,i,t){"use strict";t.r(i);var e=t(0),a=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,i=n.$createElement,t=n._self._c||i;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"css3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css3","aria-hidden":"true"}},[n._v("#")]),n._v(" CSS3 🎉 💯")]),n._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[n._v("TIP")]),n._v(" "),t("p",[n._v("This is a note about css")])]),n._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#css3有哪些新特性？"}},[n._v("CSS3有哪些新特性？")])]),t("li",[t("a",{attrs:{href:"#position的absolute与fixed共同点与不同点"}},[n._v("position的absolute与fixed共同点与不同点")])]),t("li",[t("a",{attrs:{href:"#请列举几种清除浮动的方法-至少两种"}},[n._v("请列举几种清除浮动的方法(至少两种)")])]),t("li",[t("a",{attrs:{href:"#隐藏元素display-none-与-visibility-hidden-的区别"}},[n._v("隐藏元素display: none; 与 visibility: hidden; 的区别")])]),t("li",[t("a",{attrs:{href:"#居中方式"}},[n._v("居中方式")])]),t("li",[t("a",{attrs:{href:"#怎么实现动画，canvas动画与svg区别"}},[n._v("怎么实现动画，canvas动画与svg区别")])])])]),t("p"),n._v(" "),t("h2",{attrs:{id:"css3有哪些新特性？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css3有哪些新特性？","aria-hidden":"true"}},[n._v("#")]),n._v(" CSS3有哪些新特性？")]),n._v(" "),t("h2",{attrs:{id:"position的absolute与fixed共同点与不同点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#position的absolute与fixed共同点与不同点","aria-hidden":"true"}},[n._v("#")]),n._v(" position的absolute与fixed共同点与不同点")]),n._v(" "),t("p",[n._v("A：共同点：\n1.改变行内元素的呈现方式，display被置为inline-block；\n2.让元素脱离普通流，不占据空间；\n3.默认会覆盖到非定位元素上")]),n._v(" "),t("p",[n._v("B不同点：\nabsolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。\n当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。")]),n._v(" "),t("h2",{attrs:{id:"请列举几种清除浮动的方法-至少两种"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请列举几种清除浮动的方法-至少两种","aria-hidden":"true"}},[n._v("#")]),n._v(" 请列举几种清除浮动的方法(至少两种)")]),n._v(" "),t("p",[n._v("父级div定义 overflow:hidden\n原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度\n优点：简单、代码少、浏览器支持好\n缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。\n建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。\n父级div定义 overflow:auto\n原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度\n优点：简单、代码少、浏览器支持好\n缺点：内部宽高超过父级div时，会出现滚动条。\n建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。\n盒模型\n盒模型有两种， IE 怪异盒子模型、W3C标准盒子模型；\n盒模型是由： 内容(content)、内边距(padding)、边框(border)、外边距(margin) 组成的。\n标准模型的宽高是指的content区宽高； IE盒模型的宽高是指的content+padding+border的宽高。\nCSS如何设置这两种盒模型？\n标准盒模型：\nbox-sizing: content-box;\n怪异盒模型：\nbox-sizing: border-box;\na、box-sizing:content-box： padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin ) 此属性表现为标准模式下的盒模型。\nb、box-sizing:border-box： padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 此属性表现为怪异模式下的盒模型。")]),n._v(" "),t("h2",{attrs:{id:"隐藏元素display-none-与-visibility-hidden-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐藏元素display-none-与-visibility-hidden-的区别","aria-hidden":"true"}},[n._v("#")]),n._v(" 隐藏元素display: none; 与 visibility: hidden; 的区别")]),n._v(" "),t("p",[n._v("相同： 它们都能让元素不可见\n区别：\ndisplay:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见\ndisplay: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了 hidden，通过设置 visibility: visible;可以让子孙节点显式\n修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘\n读屏器不会读取 display: none;元素内容；会读取 visibility: hidden 元素内容")]),n._v(" "),t("h2",{attrs:{id:"居中方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#居中方式","aria-hidden":"true"}},[n._v("#")]),n._v(" 居中方式")]),n._v(" "),t("p",[n._v("水平垂直居中\n被居中元素宽高固定\n绝对定位，top和left 为 50%， margin的left和top为自身宽高一半\n.center {\nposition: absolute;\ntop: 50%;\nleft: 50%;\nmargin-left: -9rem;\nmargin-top: -5rem;\n}\n绝对定位，top和lefe为父元素一半剪自身一半\n.center {\nposition: absolute;\ntop: calc(50% - 5em);\nleft: calc(50% - 9em);\n}\n被居中元素宽高不定\n使用CSS3 的 transform将位置在中心点平移自身宽高一半\n.center {\nposition: absolute;\ntop: 50%;\nleft: 50%;\ntransform: translate(-50%, -50%);\n}\ncss的flex  使用flex布局居中\n.wrapper {\ndisplay: flex;\n}\n.center {\nmargin:  0 auto;\n}\nflex布局，父元素指定子元素居中。\n.wrapper {\ndisplay: flex;\nalign-items: center;\njustify-content: center;\n}\n在浏览器窗口中居中\n基于视口的垂直居中。不要求原生有固定的宽高，但是这种居中是在整个页面窗口内居中，不是基于父元素")]),n._v(" "),t("p",[n._v(".center{\nmargin: 50vh auto;\ntransform: translateY(-50%);\n}")]),n._v(" "),t("h2",{attrs:{id:"怎么实现动画，canvas动画与svg区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么实现动画，canvas动画与svg区别","aria-hidden":"true"}},[n._v("#")]),n._v(" 怎么实现动画，canvas动画与svg区别")]),n._v(" "),t("p",[n._v("canvas H5 画布"),t("br"),n._v("\n通过Javascript来绘制2D图形。\n是逐像素进行渲染的。\n其位置发生改变，会重新进行绘制\nsvg 只能绘矢量图\n一种使用XML描述的2D图形的语言\nSVG基于XML意味着，SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。\n在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。")]),n._v(" "),t("p",[n._v("Canvas\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以 .png 或 .jpg 格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\nSVG\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n不适合游戏应用")])])}],!1,null,null,null);i.default=a.exports}}]);