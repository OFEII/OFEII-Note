(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{166:function(e,n,t){"use strict";t.r(n);var s=t(0),a=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),t("h2",{attrs:{id:"参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参数","aria-hidden":"true"}},[e._v("#")]),e._v(" 参数")]),e._v(" "),t("p",[e._v("是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。")]),e._v(" "),t("p",[e._v("Promise 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了。\n等待中（pending）\n完成了（resolved）\n拒绝了（rejected）\n当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的。")]),e._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[e._v("new Promise"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("((")]),e._v("resolve, reject"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  console.log"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'new Promise'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  resolve"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'success'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nconsole.log"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'finifsh'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),t("p",[e._v("// 先打印new Promise， 再打印 finifsh\nPromise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装。\nPromise.resolve(1)\n.then(res => {\nconsole.log(res) // => 1\nreturn 2 // 包装成 Promise.resolve(2)\n})\n.then(res => {\nconsole.log(res) // => 2\n})\n当然了，Promise 也很好地解决了回调地狱的问题\najax(url)\n.then(res => {\nconsole.log(res)\nreturn ajax(url1)\n}).then(res => {\nconsole.log(res)\nreturn ajax(url2)\n}).then(res => console.log(res))\n手写Promise\n先看看Promise是怎么用的\nnew MyPromise((resolve, reject) => {\nsetTimeout(() => {\nresolve(1)\n}, 0)\n}).then(value => {\nconsole.log(value)\n})\n在Promise的构造器中传入一个函数，这个函数有两个参数 resolve和reject，这两个参数都是Promise的回调函数，不需要自己写，在需要的时候调用就可以了，他们分别是成功的回调resolve和失败的回调reject。\n简易版 Promise\n第一步，先来搭建构建函数的大体框架\nconst PENDING = 'pending'\nconst RESOLVED = 'resolved'\nconst REJECTED = 'rejected'")]),e._v(" "),t("p",[e._v("function MyPromise(fn){\nconst that = this\nthat.state = PENDING\nthat.value = null\nthat.resolvedCallbacks = []\nthat.rejectedCallbacks = []\n// 待完善 resolve 和 reject 函数\n// 待完善执行 fn 函数\n}\n首先创建三个常量用于表示状态，对于经常使用的一些值应该通过常量来管理，便于开发及后期维护\n在函数体内部首先创建常量that，因为代码可能会异步执行，用于获取正确的this对象\n一开始Promise的状态是 pending\nvalue 变量用于保存resolve或者reject中传入的值\nresolvedCallbacks和rejectedCallback用于保存then中的回调，因为当执行完Promise时状态可能还是等待中，这时候应该把then中的回调保存起来用于状态改变时使用\n第二步，完善resolve和reject函数，添加在 MyPromise 函数体内部\nfunction resolve(value) {\nif(that.state === PENDING) {\nthat.state = RESOLVED\nthat.value = value\nthat.resolvedCallbacks.map(cb => cb(that.value))\n}\n}")]),e._v(" "),t("p",[e._v("function reject(value) {\nif(that.state === PENDING){\nthat.state = REJECTED\nthat.value = value;\nthat.rejectedCallbacks.map(cb => cb(that.value));\n}\n}\n首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态\n将当前状态更改为对应状态，并且将传入的值赋值给 value\n遍历回调数组并执行\n第四步，实现如何执行 Promise 中传入的函数了\ntry {\nfn(resolve, reject)\n} catch (e) {\nreject(e)\n}\n实现很简单，执行传入的参数并且将之前两个函数当做参数传进去\n要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数\n第五步，实现较为复杂的 then 函数。\nthen函数是在Promise构造器中成功状态下调用的resolve方法的回调。\nthen函数是可以接收两个参数的，一个是用户自定义的成功处理，另一个是用户自定义的错误处理，第二个参数可不传。\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\nconst that = this\n//对传入的两个参数做判断，如果不是函数将其转为函数\nonFulfilled =\ntypeof onFulfilled === 'function'\n? onFulfilled\n: v => v  // onFulfilled = v => v\nonRejected =\ntypeof onRejected === 'function'\n? onRejected\n: r => {\nthrow r\n}")]),e._v(" "),t("p",[e._v("if(that.state === PENDING) {\nthat.resolvedCallbacks.push(onFulfilled)\nthat.rejectedCallbacks.push(onRejected)\n}\nelse if(that.state === RESOLVED) {\nonFulfilled(that.value)\n}\nelse {\nonRejected(that.value)\n}\n}\n首先判断两个参数是否为函数类型，因为这两个参数是可选参数\n当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码\n// 该代码目前在简单版中会报错\n// 只是作为一个透传的例子\nPromise.resolve(4).then().then((value) => console.log(value))\n接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑")])])}],!1,null,null,null);n.default=a.exports}}]);