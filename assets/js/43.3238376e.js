(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{202:function(_,v,t){"use strict";t.r(v);var a=t(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"tcp-http-https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-http-https","aria-hidden":"true"}},[_._v("#")]),_._v(" TCP HTTP HTTPS")]),_._v(" "),t("h2",{attrs:{id:"http1-1和http2-0的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http1-1和http2-0的区别","aria-hidden":"true"}},[_._v("#")]),_._v(" http1.1和http2.0的区别")]),_._v(" "),t("ul",[t("li",[_._v("二进制格式 HTTP/2采用二进制格式而非文本格式")]),_._v(" "),t("li",[_._v("多路复用 HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行")]),_._v(" "),t("li",[_._v("header压缩 使用报头压缩，HTTP/2降低了开销")]),_._v(" "),t("li",[_._v("服务端推送 HTTP/2让服务器可以将响应主动“推送”到客户端缓存中")])]),_._v(" "),t("h2",{attrs:{id:"http-长短轮询-连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-长短轮询-连接","aria-hidden":"true"}},[_._v("#")]),_._v(" http 长短轮询/连接")]),_._v(" "),t("ul",[t("li",[_._v("短轮询：重复发送Http请求，查询目标事件是否完成，优点：编写简单，缺点：浪费带宽和服务器资源")]),_._v(" "),t("li",[_._v("长轮询：在服务端hold住Http请求（死循环或者sleep等等方式），等到目标时间发生，返回Http响应。优点：在无消息的情况下不会频繁的请求，缺点：编写复杂")]),_._v(" "),t("li",[_._v("短连接：每次Http请求都会建立Tcp连接，管理容易")]),_._v(" "),t("li",[_._v("长连接：只需要建立一次Tcp连接，以后Http请求重复使用同一个Tcp连接，管理难")])]),_._v(" "),t("h2",{attrs:{id:"http和https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http和https","aria-hidden":"true"}},[_._v("#")]),_._v(" http和https")]),_._v(" "),t("p",[_._v("HTTP协议传输的数据都是未加密的，明文，传输隐私信息非常不安全，为保证隐私数据能加密传输，")]),_._v(" "),t("p",[_._v("SSL/TLS     ( Secure Sockets Layer）协议 + HTTP=HTTPS")]),_._v(" "),t("p",[t("strong",[_._v("HTTPS和HTTP的区别主要如下：")])]),_._v(" "),t("p",[_._v("1、https协议需要到ca申请证书，需要一定费用。")]),_._v(" "),t("p",[_._v("2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。")]),_._v(" "),t("p",[_._v("3、http和https使用的是完全不同的连接方式，用的端口也不同，前者是80，后者是443。")]),_._v(" "),t("p",[_._v("4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。")]),_._v(" "),t("h2",{attrs:{id:"tcp慢启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp慢启动","aria-hidden":"true"}},[_._v("#")]),_._v(" tcp慢启动")]),_._v(" "),t("ul",[t("li",[_._v("TCP慢启动")])]),_._v(" "),t("p",[_._v("TCP在连接过程的三次握手完成后，开始传数据，并不是一开始向网络通道中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞；")]),_._v(" "),t("p",[_._v("而是根据初始的cwnd大小逐步增加发送的数据量，cwnd初始化为1个最大报文段(MSS)大小（这个值可配置不一定是1个MSS）；每当有一个报文段被确认，cwnd大小指数增长。")]),_._v(" "),t("p",[_._v("开始 —> cwnd = 1\n1个RTT后 —> cwnd = 2"),t("em",[_._v("1 = 2\n2个RTT后 —> cwnd = 2")]),_._v("2= 4\n3个RTT后 —> cwnd = 4*2 = 8")]),_._v(" "),t("ul",[t("li",[_._v("拥塞避免")])]),_._v(" "),t("p",[_._v("cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，一旦cwnd>=ssthresh（大多数TCP的实现，通常大小都是65536），慢启动过程结束，拥塞避免阶段开始；")]),_._v(" "),t("p",[_._v("拥塞避免：cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。")]),_._v(" "),t("p",[_._v("非ECN环境下的拥塞判断，发送方RTO超时，重传了一个报文段；")]),_._v(" "),t("p",[_._v("1，把ssthresh降低为cwnd值的一半；")]),_._v(" "),t("p",[_._v("2，把cwnd重新设置为1；")]),_._v(" "),t("p",[_._v("3，重新进入慢启动过程。")]),_._v(" "),t("ul",[t("li",[_._v("快速重传")])]),_._v(" "),t("p",[_._v("快速重传，TCP在收到重复的3次ACK时，会认为重传队列中的第一个报文段被网络丢弃，但由于收到的重复的3次ACK，则认为该报文段之后的三个报文已经被接收端收到，则不等待重传定时器超时，直接重发重传队列中的第一个报文段。")]),_._v(" "),t("p",[_._v("1，把ssthresh设置为cwnd的一半")]),_._v(" "),t("p",[_._v("2，把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)")]),_._v(" "),t("p",[_._v("3，重新进入拥塞避免阶段。")]),_._v(" "),t("p",[_._v("-快速恢复")]),_._v(" "),t("p",[_._v("快速恢复的数据包守恒原则，即同一个时刻在网络中的数据包数量恒定，“老”数据包离开后，才能向网络中发送“新”的数据包。如果发送方收到一个重复的ACK，TCP的ACK机制就表明有一个数据包离开，此时cwnd加1。")]),_._v(" "),t("p",[_._v("1，当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。")]),_._v(" "),t("p",[_._v("2，再收到重复的ACK时，拥塞窗口增加1。")]),_._v(" "),t("p",[_._v("3，当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。")]),_._v(" "),t("h2",{attrs:{id:"tcp三握四挥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三握四挥","aria-hidden":"true"}},[_._v("#")]),_._v(" tcp三握四挥")]),_._v(" "),t("h3",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手","aria-hidden":"true"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),t("ul",[t("li",[_._v("第一次握手")])]),_._v(" "),t("p",[_._v("SYN = 1， seq(client) = x")]),_._v(" "),t("p",[_._v("客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。")]),_._v(" "),t("ul",[t("li",[_._v("第二次握手")])]),_._v(" "),t("p",[_._v("SYN = 1，ACK = 1，确认序号 = x+1, seq(server) = y")]),_._v(" "),t("p",[_._v("服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态")]),_._v(" "),t("ul",[t("li",[_._v("第三次握手")])]),_._v(" "),t("p",[_._v("ACK = 1，确认序号 = y+1, seq(client) = x + 1")]),_._v(" "),t("p",[_._v("客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。")]),_._v(" "),t("p",[_._v("TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。")]),_._v(" "),t("h3",{attrs:{id:"四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手","aria-hidden":"true"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),t("ul",[t("li",[_._v("第一次挥手")])]),_._v(" "),t("p",[_._v("若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。")]),_._v(" "),t("ul",[t("li",[_._v("第二次挥手")])]),_._v(" "),t("p",[_._v("B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。")]),_._v(" "),t("ul",[t("li",[_._v("第三次挥手")])]),_._v(" "),t("p",[_._v("B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入LAST-ACK状态。")]),_._v(" "),t("p",[_._v("PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。")]),_._v(" "),t("ul",[t("li",[_._v("第四次挥手")])]),_._v(" "),t("p",[_._v("A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。")]),_._v(" "),t("p",[_._v("该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。")]),_._v(" "),t("p",[_._v("当 B 收到确认应答后，也便进入 CLOSED 状态。")]),_._v(" "),t("h2",{attrs:{id:"https握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https握手","aria-hidden":"true"}},[_._v("#")]),_._v(" https握手")]),_._v(" "),t("p",[_._v("加密方式是对称还是非对称")]),_._v(" "),t("p",[_._v("对称加密（Symmetric Cryptography）  －－－共享密钥加密")]),_._v(" "),t("p",[_._v("非对称加密（Asymmetric Cryptography）  －－－公开密钥加密")]),_._v(" "),t("ul",[t("li",[_._v("对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。")]),_._v(" "),t("li",[_._v("非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。")]),_._v(" "),t("li",[_._v("解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。")])]),_._v(" "),t("h2",{attrs:{id:"https为什么安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https为什么安全","aria-hidden":"true"}},[_._v("#")]),_._v(" HTTPS为什么安全")]),_._v(" "),t("p",[_._v("（加密算法，除了对称加密/非对称加密还有哪些）")]),_._v(" "),t("ul",[t("li",[_._v("对称：MD2、4、5 HAVAL SHA")]),_._v(" "),t("li",[_._v("非对称： RSA ECC DSA")]),_._v(" "),t("li",[_._v("Hash算法：单向算法，对目标上成一段特定长度的唯一hash值，用于不可还原的密码储存，信息完整性校验")])]),_._v(" "),t("h2",{attrs:{id:"osi-七层协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#osi-七层协议","aria-hidden":"true"}},[_._v("#")]),_._v(" OSI 七层协议")]),_._v(" "),t("ul",[t("li",[_._v("应用层 A\n为应用提供通信服务")]),_._v(" "),t("li",[_._v("表示层 P\n定义数据格式以及加密")]),_._v(" "),t("li",[_._v("会话层 S\n定义了如何开始、控制、结束一个会话，包括对多个双向消息的控制和管理。")]),_._v(" "),t("li",[_._v("传输层 T\n选择差错恢复协议还是无差错恢复协议\nTCP、UDP")]),_._v(" "),t("li",[_._v("网络层 N\n端到端包传输。\n路由选择、包分解成更小的包")]),_._v(" "),t("li",[_._v("数据链路层 DL\n定义单个链路上如何传输数据")]),_._v(" "),t("li",[_._v("物理层 PH\n传输介质相关")])]),_._v(" "),t("p",[_._v("OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。")]),_._v(" "),t("p",[_._v("TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。")]),_._v(" "),t("p",[_._v("五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。")]),_._v(" "),t("h3",{attrs:{id:"每一层的协议如下："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#每一层的协议如下：","aria-hidden":"true"}},[_._v("#")]),_._v(" 每一层的协议如下：")]),_._v(" "),t("ul",[t("li",[_._v("物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）")]),_._v(" "),t("li",[_._v("数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）")]),_._v(" "),t("li",[_._v("网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）")]),_._v(" "),t("li",[_._v("传输层：TCP、UDP、SPX")]),_._v(" "),t("li",[_._v("会话层：NFS、SQL、NETBIOS、RPC")]),_._v(" "),t("li",[_._v("表示层：JPEG、MPEG、ASII")]),_._v(" "),t("li",[_._v("应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS")])]),_._v(" "),t("h3",{attrs:{id:"每一层的作用如下："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#每一层的作用如下：","aria-hidden":"true"}},[_._v("#")]),_._v(" 每一层的作用如下：")]),_._v(" "),t("ul",[t("li",[_._v("物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）")]),_._v(" "),t("li",[_._v("数据链路层：将比特组装成帧和点到点的传递（帧Frame）")]),_._v(" "),t("li",[_._v("网络层：负责数据包从源到宿的传递和网际互连（包PackeT）")]),_._v(" "),t("li",[_._v("传输层：提供端到端的可靠报文传递和错误恢复（段Segment）")]),_._v(" "),t("li",[_._v("会话层：建立、管理和终止会话（会话协议数据单元SPDU）")]),_._v(" "),t("li",[_._v("表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）")]),_._v(" "),t("li",[_._v("应用层：允许访问OSI环境的手段（应用协议数据单元APDU）")])]),_._v(" "),t("h2",{attrs:{id:"dns解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns解析","aria-hidden":"true"}},[_._v("#")]),_._v(" DNS解析")]),_._v(" "),t("p",[_._v("DNS 的作用就是通过域名查询到具体的 IP。")]),_._v(" "),t("p",[_._v("操作系统会首先在本地缓存中查询")]),_._v(" "),t("p",[_._v("没有的话会去系统配置的 DNS 服务器中查询")]),_._v(" "),t("p",[_._v("如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器")]),_._v(" "),t("p",[_._v("然后去该服务器查询 google 这个二级域名")]),_._v(" "),t("p",[_._v("接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP")]),_._v(" "),t("p",[_._v("以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。")]),_._v(" "),t("h2",{attrs:{id:"前后端如何通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前后端如何通信","aria-hidden":"true"}},[_._v("#")]),_._v(" 前后端如何通信")]),_._v(" "),t("ul",[t("li",[_._v("Ajax")]),_._v(" "),t("li",[_._v("WebSocket")]),_._v(" "),t("li",[_._v("CORS")])]),_._v(" "),t("h2",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket","aria-hidden":"true"}},[_._v("#")]),_._v(" websocket")]),_._v(" "),t("p",[_._v("在单个 TCP 连接上进行全双工通讯的协议。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。")]),_._v(" "),t("ul",[t("li",[_._v("Socket.onopen 连接建立时触发")]),_._v(" "),t("li",[_._v("Socket.onmessage 客户端接收服务端数据时触发")]),_._v(" "),t("li",[_._v("Socket.onerror 通信发生错误时触发")]),_._v(" "),t("li",[_._v("Socket.onclose 连接关闭时触发")])])])}],!1,null,null,null);v.default=s.exports}}]);