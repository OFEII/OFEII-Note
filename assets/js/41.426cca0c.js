(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{163:function(e,t,a){"use strict";a.r(t);var v=a(0),r=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[e._v("#")]),e._v(" VUE")]),e._v(" "),a("h2",{attrs:{id:"vue-的双向绑定的原理是什么-常考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的双向绑定的原理是什么-常考","aria-hidden":"true"}},[e._v("#")]),e._v(" vue 的双向绑定的原理是什么(常考)")]),e._v(" "),a("p",[e._v("vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),e._v(" "),a("p",[e._v("具体步骤：")]),e._v(" "),a("ul",[a("li",[e._v("第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化")]),e._v(" "),a("li",[e._v("第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),e._v(" "),a("li",[e._v("第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:\n在自身实例化时往属性订阅器(dep)里面添加自己\n自身必须有一个 update()方法\n待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。")]),e._v(" "),a("li",[e._v("第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。")])]),e._v(" "),a("h2",{attrs:{id:"vue-react-为什么循环要加keys字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-react-为什么循环要加keys字段","aria-hidden":"true"}},[e._v("#")]),e._v(" vue/react 为什么循环要加keys字段")]),e._v(" "),a("h2",{attrs:{id:"vue响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue响应式原理","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue响应式原理")]),e._v(" "),a("p",[e._v("把一个普通的 JS对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性\nVue通过Object.defineProperty的 getter/setter 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据")]),e._v(" "),a("h2",{attrs:{id:"v-bind和v-model的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-bind和v-model的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" v-bind和v-model的区别")]),e._v(" "),a("p",[e._v("1.v-bind用来绑定数据和属性以及表达式，缩写为'：'")]),e._v(" "),a("p",[e._v("2.v-model使用在表单中，实现双向数据绑定的，在表单元素外使用不起作用")]),e._v(" "),a("h2",{attrs:{id:"什么是-mvvm？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mvvm？","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是 mvvm？")]),e._v(" "),a("p",[e._v("MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。\n在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。")]),e._v(" "),a("h2",{attrs:{id:"mvvm-和-mvc-区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-和-mvc-区别？","aria-hidden":"true"}},[e._v("#")]),e._v(" mvvm 和 mvc 区别？")]),e._v(" "),a("p",[e._v("mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。")]),e._v(" "),a("h2",{attrs:{id:"vue-的优点是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的优点是什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" vue 的优点是什么？")]),e._v(" "),a("ul",[a("li",[e._v('低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的"View"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。')]),e._v(" "),a("li",[e._v("可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。")]),e._v(" "),a("li",[e._v("独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。")]),e._v(" "),a("li",[e._v("可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。")])]),e._v(" "),a("h2",{attrs:{id:"请详细说下你对-vue-生命周期的理解？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请详细说下你对-vue-生命周期的理解？","aria-hidden":"true"}},[e._v("#")]),e._v(" 请详细说下你对 vue 生命周期的理解？")]),e._v(" "),a("p",[e._v("答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。")]),e._v(" "),a("ul",[a("li",[e._v("创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。")]),e._v(" "),a("li",[e._v("载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实- 例挂载完成，data.message 成功渲染。")]),e._v(" "),a("li",[e._v("更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。")]),e._v(" "),a("li",[e._v("销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在")])]),e._v(" "),a("h2",{attrs:{id:"路由之间跳转？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由之间跳转？","aria-hidden":"true"}},[e._v("#")]),e._v(" 路由之间跳转？")]),e._v(" "),a("ul",[a("li",[e._v('声明式（标签跳转） router-link :to="index"')]),e._v(" "),a("li",[e._v("编程式（ js 跳转） router.push('index')")]),e._v(" "),a("li",[e._v("懒加载（按需加载路由）（常考）")]),e._v(" "),a("li",[e._v("webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。")]),e._v(" "),a("li",[e._v("不进行页面按需加载引入方式：\nimport  home   from '../../common/home.vue'")]),e._v(" "),a("li",[e._v("进行页面按需加载的引入方式：\nconst  home = r => require.ensure( [], () => r (require('../../common/home.vue')))")])]),e._v(" "),a("h2",{attrs:{id:"vuex-是什么？怎么使用？哪种功能场景使用它？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-是什么？怎么使用？哪种功能场景使用它？","aria-hidden":"true"}},[e._v("#")]),e._v(" vuex 是什么？怎么使用？哪种功能场景使用它？")]),e._v(" "),a("p",[e._v("vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 新建 store.js")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),e._v(" vue "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'vue'")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),e._v(" vuex form "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'vuex'")]),e._v("\nvue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("use")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vuex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("default")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("vuex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("store")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//...code")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//main.js")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),e._v(" store "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'./store'")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n")])])]),a("h2",{attrs:{id:"vue-router-有哪几种导航钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-有哪几种导航钩子","aria-hidden":"true"}},[e._v("#")]),e._v(" vue-router 有哪几种导航钩子?")]),e._v(" "),a("p",[e._v("三种")]),e._v(" "),a("ul",[a("li",[e._v("全局导航钩子\nrouter.beforeEach(to, from, next),")])]),e._v(" "),a("p",[e._v("router.beforeResolve(to, from, next),")]),e._v(" "),a("p",[e._v("router.afterEach(to, from ,next)")]),e._v(" "),a("ul",[a("li",[e._v("组件内钩子\nbeforeRouteEnter,")])]),e._v(" "),a("p",[e._v("beforeRouteUpdate,")]),e._v(" "),a("p",[e._v("beforeRouteLeave")]),e._v(" "),a("ul",[a("li",[e._v("单独路由独享组件\nbeforeEnter")])]),e._v(" "),a("h2",{attrs:{id:"自定义指令-v-check-v-focus-的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令-v-check-v-focus-的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数","aria-hidden":"true"}},[e._v("#")]),e._v(" 自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数")]),e._v(" "),a("ul",[a("li",[e._v("全局定义指令：在 vue 对象的 directive 方法里面有两个参数, 一个是指令名称, 另一个是函数。")]),e._v(" "),a("li",[e._v("组件内定义指令：directives")]),e._v(" "),a("li",[e._v("钩子函数: bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新)")]),e._v(" "),a("li",[e._v("钩子函数参数： el、binding")])]),e._v(" "),a("h2",{attrs:{id:"说出至少-4-种-vue-当中的指令和它的用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说出至少-4-种-vue-当中的指令和它的用法","aria-hidden":"true"}},[e._v("#")]),e._v(" 说出至少 4 种 vue 当中的指令和它的用法")]),e._v(" "),a("ul",[a("li",[e._v("v-if(判断是否隐藏)")]),e._v(" "),a("li",[e._v("v-for(把数据遍历出来)")]),e._v(" "),a("li",[e._v("v-bind(绑定属性)")]),e._v(" "),a("li",[e._v("v-model(实现双向绑定)")])]),e._v(" "),a("h2",{attrs:{id:"axios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#axios","aria-hidden":"true"}},[e._v("#")]),e._v(" axios")]),e._v(" "),a("p",[e._v("axios 是什么？怎么使用？描述使用它实现登录功能的流程")]),e._v(" "),a("p",[e._v("axios 是请求后台资源的模块。 npm i axios -S")]),e._v(" "),a("p",[e._v("如果发送的是跨域请求，需在配置文件中 config/index.js 进行配置")])])}],!1,null,null,null);t.default=r.exports}}]);