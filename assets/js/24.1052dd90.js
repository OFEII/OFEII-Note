(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{193:function(v,_,e){"use strict";e.r(_);var t=e(0),i=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"渲染render"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染render","aria-hidden":"true"}},[v._v("#")]),v._v(" 渲染Render")]),v._v(" "),e("h2",{attrs:{id:"渲染机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染机制","aria-hidden":"true"}},[v._v("#")]),v._v(" 渲染机制")]),v._v(" "),e("p",[v._v("浏览器的渲染机制一般分为以下几个步骤")]),v._v(" "),e("ul",[e("li",[v._v("处理 HTML 并构建 DOM 树。")]),v._v(" "),e("li",[v._v("处理 CSS 构建 CSSOM 树。")]),v._v(" "),e("li",[v._v("将 DOM 与 CSSOM 合并成一个渲染树。")]),v._v(" "),e("li",[v._v("根据渲染树来布局，计算每个节点的位置。")]),v._v(" "),e("li",[v._v("调用 GPU 绘制，合成图层，显示在屏幕上。")])]),v._v(" "),e("h2",{attrs:{id:"重绘（repaint）和回流（reflow）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘（repaint）和回流（reflow）","aria-hidden":"true"}},[v._v("#")]),v._v(" 重绘（Repaint）和回流（Reflow）")]),v._v(" "),e("p",[v._v("重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。")]),v._v(" "),e("p",[v._v("重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘")]),v._v(" "),e("p",[v._v("回流是布局或者几何属性需要改变就称为回流。")]),v._v(" "),e("p",[v._v("回流必定会发生重绘，重绘不一定会引发回流。")]),v._v(" "),e("p",[v._v("回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。")]),v._v(" "),e("p",[v._v("所以以下几个动作可能会导致性能问题：")]),v._v(" "),e("ul",[e("li",[v._v("改变 window 大小")]),v._v(" "),e("li",[v._v("改变字体")]),v._v(" "),e("li",[v._v("添加或删除样式")]),v._v(" "),e("li",[v._v("文字改变")]),v._v(" "),e("li",[v._v("定位或者浮动")]),v._v(" "),e("li",[v._v("盒模型")])]),v._v(" "),e("p",[v._v("很多人不知道的是，重绘和回流其实和 Event loop 有关。")]),v._v(" "),e("ul",[e("li",[v._v("当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。")]),v._v(" "),e("li",[v._v("然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。")]),v._v(" "),e("li",[v._v("判断是否触发了 media query")]),v._v(" "),e("li",[v._v("更新动画并且发送事件")]),v._v(" "),e("li",[v._v("判断是否有全屏操作事件")]),v._v(" "),e("li",[v._v("执行 requestAnimationFrame 回调")]),v._v(" "),e("li",[v._v("执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好")]),v._v(" "),e("li",[v._v("更新界面")])]),v._v(" "),e("p",[v._v("以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。")])])}],!1,null,null,null);_.default=i.exports}}]);